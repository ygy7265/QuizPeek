[
  {
    "question": "모든 구문을 한번 이상 수행하는 테스트 커버리지",
    "answer": "구문(Statement) 커버리지"
  },
  {
    "question": "결정문의 결과가 참과 거짓의 결과를 수행하는 테스트 커버리지",
    "answer": "결정(Decision) 커버리지"
  },
  {
    "question": "결정문의 결과와 결정문 내부 개별 조건식의 결과가 참과 거짓의 결과를 수행하는 테스트 커버리지",
    "answer": "조건/결정 커버리지"
  },
  {
    "question": "결정문 내부 개별 조건식 결과에 상관없이 독립적으로 전체 조건식의 결과에 영향을 주는 테스트 커버리지 (가장안전한 커버리지)",
    "answer": "변형 조건/결정 커버리지(MC/DC)"
  },
  {
    "question": "모든 조건식의 모든 가능한 논리적 조합을 고려하는 테스트 커버리지",
    "answer": "다중 조건 커버리지"
  },
  {
    "question": "상위 클래스에서는 객체를 생성하기 위한 인터페이스를 정의하고 하위클래스는 어떤 클래스의 인스턴스를 생성할 것인지 결정하는 패턴",
    "answer": "Factory Method"
  },
  {
    "question": "관련이 있는 서브 클래스를 묶어서 조건에 따라 객체를 생성하는 패턴 ,객체를 생성하기 위한 패턴이고 여러 객체군을 생성하기 귀한 패턴",
    "answer": "Abstract Factory"
  },
  {
    "question": "복잡한 객체를 단계적으로 생성하는패턴,\n 복잡한 객체 생성과정을 분리(캡슐화) 하여 동일한 절차에서도 서로 다른 객체를 생성 하는 패턴",
    "answer": "Builder"
  },
  {
    "question": "동일한 타입의 객체를 생성할때 필요한 비용을 줄이기 위한 패턴,\n 새로운 객체를 생성하는 것이 안니 기존의 객체를 복사하여 특정 속상값 변경",
    "answer": "Prototype"
  },
  {
    "question": "클래스가 오직 하나의 인스턴스만을 가지도록 하는 패턴",
    "answer": "Singleton"
  },
  {
    "question": "서로 다른 인터페이스를 가진 클래스를 함께 사용할 수 있는 패턴,\n 클래스의 인터페이스를 다른 인터페이스로 변환하여 함께 작동 해주도록 함",
    "answer": "Adapter"
  },
  {
    "question": "(느슨한 결합 유지 도움) 복잡하게 설계된 클래스를 기능부와 구현부로 분리한 뒤, 두클래스를 연결하는 패턴",
    "answer": "Bridge"
  },
  {
    "question": "객체들의 관계를 트리 구조로 구성화 하여 단일객체와 복합 객체를 동일하게 다루는 패턴\n 다수의 클래스를 하나의 클래스로 취급가능",
    "answer": "Composite"
  },
  {
    "question": "클래스 변경없이 주어진 상황에 따라 추가하는 패턴\n 기존 클래스의 메소드에 새로운 기능 추가 및 확장 가능",
    "answer": "Decorater"
  },
  {
    "question": "복잡한 서브 시스템을 간편하게 사용할 수 있도록 단순화 된 인터페이스를 제공,\n 다수의 하위 클래스들이 올바른 결합도를 갖도록 하여 의존 관계를 줄이고 복잡성을 낮출수 있는 패턴",
    "answer": "Facade"
  },
  {
    "question": "메모리 사용량을 최소화 하기 위해 객체간 데이터공유를 극대화하는 패턴 \n사용빈도가 높을 것으로 예상되는 데이터를 중복생성 하지 않고 외부 자료 구조에 저장하여 활용하는 패턴",
    "answer": "Flyweight"
  },
  {
    "question": "특정 객체로의 접근을 해당객체의 대리자를 통해 진행하는 패턴",
    "answer": "Proxy"
  },
  {
    "question": "언어의 문법을 평가하는 방법을 규정하는 패턴",
    "answer": "Interpreter"
  },
  {
    "question": "상위 클래스에서 알고리즘의 뼈대를 정의하고 구체적인 단계는 하위 클래스에서 정의하는 패턴\n 알고리즘의 구조(고정적 기능)를 변경하지 않고 알고리즘의 특정 단계들을 재정의할 수 있다.",
    "answer": "Tepmlate Method"
  },
  {
    "question": "문제의 해결을 위한 일련의 처리 객체가 순서대로 문제를 해결하는 패턴\n 각각 처리객체는 문제의 일정 부분을 처리할 수 있는 연산의 집합이고, 처리 객체에 의해 일부분이 해결된 문제는 다음 처리 객체로 넘겨져 계속 처리 된다.",
    "answer": "Chain of Responsibility"
  },
  {
    "question": "요정을 객체의 형태로 캡슐화 하여 나중이 이용할 수 있도록 요청에 필요한 정보를 저장하는 패턴\n 메소드 이름, 매개변수 등의 정보를 저장하여 복구,최소 등이 가능하다.",
    "answer": "Command"
  },
  {
    "question": "내부 구현을 노출시키지 않고 집약된(집합) 객체에 접근하고 싶을때 적용하는 패턴",
    "answer": "Iterator"
  },
  {
    "question": "(느슨한 결합 유지 도움) 객체 간의 통신이 직접 이루어 지지 않고 중재자를 통해 결합도를 감소 시키는 패턴",
    "answer": "Mediator"
  },
  {
    "question": "롤백을 통해 객체의 상태를 이전 상태로 되돌릴 수 있는 기능을 제공하는 패턴\n 객체의 캡슐화가 유지되는 상태에서 객체 내부 상태를 외부에 저장하여 복구가 가능하도록 한다.",
    "answer": "Memento"
  },
  {
    "question": "객체의 상태변화를 관찰하는 ? 등록하여 상태 변화가 있을때 마다 등록된 ? 통지하는 패턴",
    "answer": "Observer"
  },
  {
    "question": "객체의 내부 상태에 따라 다른 기능을 수행하는 패턴 \n 객체의 상태에 따라 동일한 루틴에서도 다른 행동을 할 수 있다.",
    "answer": "State"
  },
  {
    "question": "문제를 해결하는 데 있어 다양한 알고리즘이 적용할수 있는 경우에 알고리즘을 별도로 분리(캡슐화) 하는 패턴\n 특정 객체에 종속 되지않으며 알고리즘에 확장가 변경에 용이함.",
    "answer": "Strategy"
  },
  {
    "question": "알고리즘을 자료 구조에서 분리하여 클래스를 수정하지 않고도 새로운 알고리즘을 추가할 수 있도록 하는 패턴",
    "answer": "Visitor"
  },
  {
    "question": "패킷의 전송 순서는 바뀌지않고 체증이 비교적 많이 발생하며, 논리적 연결 설정 작업을 한뒤 패킷 교환 방식은 ?",
    "answer": "가상 회선 패킷 교환 방식"
  },
  {
    "question": "논리적 경로의 확보 없이 자유롭게 데이터 패킷 전송하는 방식, 패킷의 전송 순서는 바뀔수 있고 체증이 덜 발생함.",
    "answer": "데이터 그램 패킷 교환 방식"
  },
  {
    "question": "64bit 블록 크기를 가지며 byte별로 1bit의 패리티 bit 를 가지는 암호 알고리즘 은 ?",
    "answer": "DES"
  },
  {
    "question": "키의 길이에 따라 10/12/14 라운드를 진행하고,128bit의 블록크기와 가변 길이 키(128,192,256) 을 가지고,DES를 대체하는 미국의 표준 대칭키 암호화 알고리즘은?",
    "answer": "AES"
  },
  {
    "question": "64bit의 블록크기를 가지고 키길이는 128bit 8라운드 진행하고, DES 를 대체하기 위해 스위스에서 개발된 알고리즘은 ?",
    "answer": "IDEA"
  },
  {
    "question": "128bit 블록 크기와 128bit의 키길이를 가지며 16라운드 진행하고 ARIA 이전 국내 표준 알고리즘은 ?",
    "answer": "SEED"
  },
  {
    "question": "AES 알고리즘이 개선된 것 으로 128bit의 블록크기, 키길이(128,192,256)에 따라 라운드 (12,14,16)을 진행하고 국내 공공기관에서 사용하는 알고리즘은 ?",
    "answer": "ARIA"
  },
  {
    "question": "다양한 크기의 키 블록, 라운드를 가질 수 있는 블록 암호화 알고리즘, 단순하고 빠르며 메모리 요규량이 낮은편,",
    "answer": "RC5"
  },
  {
    "question": "유선 LAN 에서 기대할수 있는 수준의 무선 LAN 보안 프로토콜",
    "answer": "WEP(Wired Equivalent Privacy)"
  },
  {
    "question": "IEEE 802.11 무선랜 보안에 사용된 웹방식을 보완한 데이터 보안 프로토콜\n ( 1 ) 기반의 무선랜 보안 표준을 ( 2 ) 라고 한다",
    "answer": "1. TKIP(Temporal Key Integrity Protocol) 2. WPA(Wi-fi Protected Access)"
  },
  {
    "question": "SSL 공동인증서 등에 활용하고있는, 큰 합성수의 소인수 분해가 어렵다는 점을 이용한 알고리즘으로 키의 길이가 길고 속도가 느린편인 암호화는 ?",
    "answer": "RSA(Rivest Shamir Adleman)"
  },
  {
    "question": "RSA의 대안으로 대두된 이산대수의 난해성에 기반한 공개키 암호화 알고리즘, 비트코인 등에서 사용 RSA 보다 수십 배 빠름",
    "answer": "ECC(elliptic Curve Crypto)"
  },
  {
    "question": "미국 NIST에서 전자서명 표준에서 사용하기 위해 정부용 공개키 알고리즘 EIGammal 알고리즘을 기반으로 만들어짐",
    "answer": "DSA"
  },
  {
    "question": "암호화 알고리즘이 아닌 데이터 무결성을 점검하기 위한 해시 알고 리즘으로 128 해시값을 가진다.",
    "answer": "MD5(Message Digest 5)"
  },
  {
    "question": "MD 를 대체하기 위해 미국 NIST 에서 개발한 해시 암호화 알고리즘",
    "answer": "SHA(Secure Hash Algorithm)"
  },
  {
    "question": "모듈과 모듈 간의 관련성이 얼마나 깊은지 나타내는 정도",
    "answer": "결합도"
  },
  {
    "question": "결합도 의 낮은 순서 부터 높은 순서 까지 나열하시오.",
    "answer": "자료 -> 스탬프 -> 제어 -> 외부 -> 공통 -> 내용"
  },
  {
    "question": "모듈 간의 인터페이스로 전달되는 (1 )와 (2) 를 통해서만 상호 작용이 일어나는 결합도는 ?",
    "answer": "1. 인수 2. 매개변수 3. 자료(Data) 결합도"
  },
  {
    "question": "관련 있는 모듈들이 동일한 자료구조를 공유하는 결합도,\n 특정 모듈에서 자료구조를 변화 시켰다면, 관련있는 다른 모듈이 그영향을 미친다.",
    "answer": "스탬프(Stamp) 결합도"
  },
  {
    "question": "전달 대상 모듈에게 값만 전달하는 것이 아니라 제어 요소를 함께 전달하는 결합도는 ?\n전달되는 제어 요소에 따라 대상 모듈의 처리절차가 달라진다.",
    "answer": "제어(Control) 결합도"
  },
  {
    "question": "인수의 전달 없이 특정 모듈이 다른 모듈의 내부 데이터를 참조하는 경우의 결합도는 ?",
    "answer": "외부(External) 결합도"
  },
  {
    "question": "모듈이 다른 모듈의 내부기능과 데이터를 직접적으로 사용하는경우의 결합도는 ?",
    "answer": "내용 (Content)결합도"
  },
  {
    "question": "모듈의 내부 요소들의 관계가 얼마나 밀접한지를 나타내는 정도는?",
    "answer": "모듈 응집도(Cohesion)"
  },
  {
    "question": "응집도가 낮은것부터 높은거까지 나열하시오.",
    "answer": "우연적 -> 논리적 -> 시간적 -> 절차적 -> 통신적 -> 순차적 -> 기능적"
  },
  {
    "question": "모든 기능 요소들이 하나의 문제를 해결하기 위해 수행되는 경우,\n모듈은 계층적으로 구성",
    "answer": "기능적(Functional) 응집도"
  },
  {
    "question": "모듈의 기능 수행으로 인한 출력 결과를 다른 모듈의 입력 값으로 사용하는 경우의 응집도",
    "answer": "순차적(Sequential) 응집도"
  },
  {
    "question": "동일한 입력을 기반으로 수행된 기능의 출력 결과를 이욜하여 서로 다른 기능을 수행하는경우의 응집도",
    "answer": "통신적(Communication)응집도"
  },
  {
    "question": "하나의 문제를 해결하기 위해 여러 모듈들이 순차적으로 수행되는경우의 응집도",
    "answer": "절차적(Procedural)응집도"
  },
  {
    "question": "각 기능들의 연관성은 없지만 특정시기에 함께 수행되어야하는 경우의 응집도",
    "answer": "시간적(Temporal) 응집도"
  },
  {
    "question": "유사한 성격이나 형태를 가진 기능을 하나의 모듈에서 수행되도록 하는 경우의 응집도",
    "answer": "논리적(Logical) 응집도"
  },
  {
    "question": "모듈내부의 구성 요소들이 서로 아무런 관련이 없는 견우의 응집도",
    "answer": "우연적(Coincidental) 응집도"
  },
  {
    "question": "규정된 크기 이상의 ( 1 ) 패킷을 전송하여 Dos를 유발 시키거나 과부화로 인한 Crashing, 리부팅 등을 유발하는 공격방법은?",
    "answer": "1.ICMP 2. 죽음의 핑(Ping of Death)"
  },
  {
    "question": "TCP의 3-Way-Handshake 취약점을 이용한 공격으로 다량의 SYN 패킷을 보내 백로그 큐를 가득 채워 다른 연결을 받아 들이지 못하게하는 공격 방식은?",
    "answer": "SYN Flooding"
  },
  {
    "question": "(1 ) 프로토콜의 취약점을 이용한 공격으로 여러 호스트가 특정 대상에서 (1) Ehco Reply 를 보내게 하여 서비스 거부(Dos) 를 유발시키는 보안 공격은 ?",
    "answer": "Smurf"
  },
  {
    "question": "분산된 다수의 좀시 PC(악성 Bot)를 이용하여 공격 대상 시스템를 마비시키는 공격 방식은 ?",
    "answer": "DDos(Distributed Denial Of Service)"
  },
  {
    "question": "공격자가 패킷의 출발지 주소나 포트를 임의로 변경하여 출발지와 목적지 주소를 동일하게 함으로써 공격 대상 컴퓨터의 실행속도를 느리게하거나 동작을 마비시켜 서비스 거부 상태에 빠지도록 하는 공격방법은 ?",
    "answer": "LAND(Local Area Network Denial Attack)"
  },
  {
    "question": "정상적인 파일로 가장해 컴퓨터 내부에 숨어 있다가 특정 포트를 열어 공격자의 침일을 도와 정보를 유출시킨다\n자체 감염 기능은 존재하지않는다.",
    "answer": "트로이목마(Trojan Horse)"
  },
  {
    "question": "사용자 동의 없이 설치 되어 컴퓨터의 정보를 수집하는 소프트웨어는?",
    "answer": "스파이웨어(SpyWare)"
  },
  {
    "question": "바이러스 처럼 다른 파일에 기생하지않고 독립적으로 자신을 복제하여 확산한다.",
    "answer": "웜(Worm)"
  },
  {
    "question": "정상적인 파일에 기상하여 존재하며 자신을 끊임없이 복제한다.",
    "answer": "바이러스"
  },
  {
    "question": "키보드 입력을 모두 기로갛여 그안에 중요 정보를 탈취하는 도구",
    "answer": "키로거(Key Logger)"
  },
  {
    "question": "인터넷 사용자의 컴퓨터에 침임하여 내부 문서 및 파일을 암호화한 뒤에 암호 해독용 프로그램을 제공하는 조건으로 사용자에게 돈을 요구하는 공격 방식",
    "answer": "랜섬웨어(Ransomware)"
  },
  {
    "question": "네트워크 상의 컴퓨터와 가동 서비스를 탐색하여 장비 구성, 포트 구성등을 파악하는 보안공격방식?",
    "answer": "스캐닝(Scanning)"
  },
  {
    "question": "네트워크상에 전송되는 트래픽을 훔쳐보는 행위",
    "answer": "스니핑(Sniffing)"
  },
  {
    "question": "스니핑과 유사한 용어로 네트워크상에 떠도는 중요 정보를 몰래 획득하는 행위",
    "answer": "스누핑(Snooping)"
  },
  {
    "question": "가장 단순한 암호해독 방법으로 패스워드를 차직위해 가능성이 있는 모든 값을 전부 대입해보는 공격은?",
    "answer": "무차별 대입 공격(Brute Force Attack)"
  },
  {
    "question": "암호가 걸려있는 정품 소프트웨어의 암호화를 풀어 불법적으로 무제한으로 사용할수있게하는것은?",
    "answer": "크랙(Crack)"
  },
  {
    "question": "블루투스의 취약점을 이용하여 목표장비의 임의 파일에 접근하는 공격방법은?",
    "answer": "블루스나핑(Blue Snarfing)"
  },
  {
    "question": "블루투스 장비간의 취약한 연결 관리를 악용한 공격으로 공격 장치와 공격 대상 장치에서 임의의 동작(전화,SMS) 을 실행하는 공격 방법",
    "answer": "블루버깅(Blue Bugging)"
  },
  {
    "question": "블루투스를 이용해 스팸처럼 명함 등을 익명으로 전송하는 공격 방법",
    "answer": "블루재킹(Blue Jacking)"
  },
  {
    "question": "통신을 연결하는 두사람 사이에 중간자가 침입 한 후, 네트워크 통신을 조작하여 통신 내용ㅇ을 도청하거나 조작하는 공격기법?",
    "answer": "중간자 공격(Man In The Middle)"
  },
  {
    "question": "중간자 공격등으로 유출된 암호나 토큰 등을 재전송함으로써 승인된 사용자가 오인하게 만들어 공격하는 기법?",
    "answer": "재전송 공격(Replay Attack)"
  },
  {
    "question": "SQL을 주입하여 의도하지않은 명령어를 수행하는 공격기법",
    "answer": "SQL Injection"
  },
  {
    "question": "웹 페이지에 악의적입 스크립트를 포함시켜 사용자측에서 실행되게끔 유도하는 공격",
    "answer": "XSS(Cross-Site-Scripting)"
  },
  {
    "question": "특정 취약점에 대한 보안 패치나 대응법이 발표되기 전에 해당 취약점을 이용하여 위협을 가하는 공격 방법",
    "answer": "제로데이 공격(Zero Day Attack)"
  },
  {
    "question": "백도어,트로이목마설치,원격접근,내부 사용 흔적 삭제, 관리자 권한 획득 등 주로 불법적인 해킹에 사용되는 기능들을 제공하는 프로그램의 모음?",
    "answer": "RootKit"
  },
  {
    "question": "해커가 이용자몰래 컴퓨터에 접속하여 악의적인 행위를 하기 위해 설치해 놓은 출입통로 역할을 하는 악성코드?",
    "answer": "백도아(BackDoor)"
  },
  {
    "question": "원본 데이터에 대한 해쉬값을 미리 계산하여 사전 형태(레인보우 테이블)로 만들어놓고 하나하나 대입해보는 공격 방법",
    "answer": "사전공격(Dictionary Attack)"
  },
  {
    "question": "정당한 사용자가 수행한 세션 인증을 가로체어 중요자원에 접근하는공격 방법",
    "answer": "세션 하이재킹(Session Hijacking)"
  },
  {
    "question": "보안 공격을 위해 자신을 다른주체(권한 있는 주체)로 속이는 행위\n IP,MAC 주소 변경 등",
    "answer": "스푸핑(spoofing)"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  }
]
