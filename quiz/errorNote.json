[
  {
    "question": "전체 조건식의 참과 거짓 결과에 상관없이 결정 포인트 내에 있는 모든 개별 조건식이 참 한번, 거짓 한번을 모두 갖도록 조합하는 커버리지",
    "answer": "다중 조건 커버리지"
  },
  {
    "question": "복잡한 서브 시스템을 간편하게 사용할 수 있도록 단순화 된 인터페이스를 제공,\n 다수의 하위 클래스들이 올바른 결합도를 갖도록 하여 의존 관계를 줄이고 복잡성을 낮출수 있는 패턴",
    "answer": "Facade"
  },
  {
    "question": "응집도가 낮은것부터 높은거까지 나열하시오.",
    "answer": "우연적 -> 논리적 -> 시간적 -> 절차적 -> 통신적 -> 순차적 -> 기능적"
  },
  {
    "question": "MD 를 대체하기 위해 미국 NIST 에서 개발한 해시 암호화 알고리즘",
    "answer": "SHA(Secure Hash Algorithm)"
  },
  {
    "question": "① 프로세서(processor) 안에 독립적인 보안 구역을 따로 두어 중요한 정보를 보호하는 하드웨어 기반의 보안 기술로, 암(ARM: Advanced RISC Machine)사에서 개발하였다. 프로세서(processor) 안에 독립적인 보안 구역을 따로 두어 중요한 정보를 보호하는 하드웨어 기반의 보안 기술\n\n② 네티즌들이 사이트에 접속할 때 주소를 잘못 입력하거나 철자를 빠뜨리는 실수를 이용하기 위해 이와 유사한 유명 도메인을 미리 등록하는 일로, URL 하이재킹(hijacking)이라고도 한다. ",
    "answer": "① ㉠ Trust Zone  ② ㉡ 타이포스쿼팅"
  },
  {
    "question": "문제를 해결하는 데 있어 다양한 알고리즘이 적용할수 있는 경우에 알고리즘을 별도로 분리(캡슐화) 하는 패턴\n 특정 객체에 종속 되지않으며 알고리즘에 확장가 변경에 용이함.",
    "answer": "Strategy"
  },
  {
    "question": "\n17. 다음은 UML에 관한 설명이다. 괄호안에 알맞는 답을 작성하시오.\n\n \n\nUML은 통합 모델링 언어로써, 시스템을 모델로 표현해주는 대표적인 모델링 언어이다.\n\n \n\n구성 요소로는 사물, (    1    ), 다이어그램으로 이루어져 있으며, 구조 다이어그램 중, (     2    ) 다이어그램은 시스템에서 사용되는 객체 타입을 정의하고, 그들 간의 존재하는 정적인 관계를 다양한 방식으로 표현한 다이어그램이다. \n\n \n\n또한 UML 모델링에서 (     3    )은/는 클래스와 같은 기타 모델 요소 또는 컴포넌트가 구현해야 하는 오퍼레이션 세트를 정의하는 모델 요소이다",
    "answer": "1. 관계\n\n2. 클래스\n\n3. 인터페이스"
  },
  {
    "question": "1. 라우터로 상호 접속이 되어있는 여러 개의 네트워크 집합으로 도메인 혹은 자율시스템(Autonomous System, AS)이라고 한다.\n\n같은 도메인 내에 존재하는 라우터는 도메인 내부 라우터가 되고 도메인 외부에 존재하는 라우터는 도메인 외부 라우터가 되는데, 여기서 도메인 내부 경로 설정을 가르킨다.\n\n \n\n2. 시스템 사이에 경로 설정 정보 등을 교환하기 위해 사용하는 프로토콜로써,\n다른 도메인 사이에 라우팅 시 정리된 관리가 거의 없고 많은 경우에 신용도가 매우 낮아 빠른 수행보다는 보안과 제어가 본래의 목적이다.\n\n \n\n3. IP 라우팅 프로토콜의 한 종류로써 RIP(routing information protocol)보다 규모가 큰 네트워크에서도 사용할 수 있다.\n규모가 크고 복잡한 TCP/IP 네트워크에서 RIP의 단점을 개선한 라우팅 프로토콜로써 RIP에 비해 자세한 제어가 가능하고, 관리 정보의 트래픽도 줄일 수 있다.\n\n \n\n4. 서로 다른 자율 시스템(AS)의 라우터 간에 라우팅 정보를 교환하는 데 사용되는 외부 게이트웨이 프로토콜(EGP)이다.\n각 목적지에 대한 전체 경로가 포함되며, 다른 시스템과 교환하는 네트워크 도달 가능성 정보의 데이터베이스를 유지한다.\n네트워크 도달 가능성 정보를 사용하여 AS 연결 그래프를 구성하며, 이를 통해 라우팅 루프를 제거하고 AS 수준에서 정책 결정을 실행할 수 있다.",
    "answer": "1. IGP\n\n2. EGP\n\n3. OSPF\n\n4. BGP"
  },
  {
    "question": "다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우의 결합도는 무엇인가?",
    "answer": "외부 결합도"
  },
  {
    "question": "모듈 간의 인터페이스로 배열이나 오브젝트, 자료구조 등이 전달되는 경우의 결합도는 무엇인가?",
    "answer": "스탬프 결합도"
  },
  {
    "question": "파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용하는 경우의 결합도는 무엇인가?",
    "answer": "공통 결합도"
  },
  {
    "question": "모듈 간에 단순히 원시 데이터 타입만 전달하는 경우 해당하는 결합도는 무엇인가?",
    "answer": "자료 결합도"
  },
  {
    "question": "모듈 간에 어떤 제어 신호나 조건에 따라 동작이 제어되는 결합도는 무엇인가?",
    "answer": "제어 결합도"
  },
  {
    "question": "모듈들이 공통의 전역 데이터나 자료구조를 공유하여 결합되는 경우의 결합도는 무엇인가?",
    "answer": "공통 결합도"
  },
  {
    "question": "한 모듈이 다른 모듈 내부의 구체적인 코드나 데이터를 직접 참조하는 매우 강한 결합도는 무엇인가?",
    "answer": "내용 결합도"
  },
  {
    "question": "모듈들이 외부 환경(파일 시스템, 데이터베이스, 운영체제 등)에 의존하여 결합되는 경우의 결합도는 무엇인가?",
    "answer": "외부 결합도"
  },
  {
    "question": "모듈 내부의 기능들이 모두 관련 있고 밀접하게 연관되어 하나의 목적을 수행하는 경우의 응집도는 무엇인가?",
    "answer": "기능적 응집도"
  },
  {
    "question": "모듈의 여러 기능들이 동일한 데이터를 사용하거나 관련 데이터를 처리하는 경우의 응집도는 무엇인가?",
    "answer": "논리적 응집도"
  },
  {
    "question": "모듈 내의 여러 기능들이 시간적으로 동시에 실행되거나 특정 시점에 실행되는 경우의 응집도는 무엇인가?",
    "answer": "시간적 응집도"
  },
  {
    "question": "모듈 내부의 구성 요소들이 단순히 순서대로 실행되는 절차적 방식으로 결합된 경우의 응집도는 무엇인가?",
    "answer": "절차적 응집도"
  },
  {
    "question": "모듈의 각 부분이 서로 매우 밀접하게 결합되어 하나의 작업을 수행하지만 분리하기 어려운 경우의 응집도는 무엇인가?",
    "answer": "우연적 응집도"
  },
  {
    "question": "모듈이 여러 기능을 수행하지만 서로 연관성이 거의 없는 경우의 응집도는 무엇인가?",
    "answer": "우연적 응집도"
  },
  {
    "question": "모듈 내부의 기능들이 통신을 위해 함께 동작하는 경우의 응집도는 무엇인가?",
    "answer": "통신적 응집도"
  },
  {
    "question": "모듈 내부 구성요소들이 기능적으로 관련되어 있으나 자료를 직접 공유하는 경우의 응집도는 무엇인가?",
    "answer": "절차적 응집도"
  },
  {
    "question": "문제를 해결하는 데 있어 다양한 알고리즘을 별도로 캡슐화하여 변경과 확장이 용이하도록 만든 디자인 패턴은 무엇인가?",
    "answer": "Strategy 패턴"
  },
  {
    "question": "객체 생성의 복잡한 과정을 서브클래스가 아닌 별도의 클래스로 분리하여 처리하는 디자인 패턴은 무엇인가?",
    "answer": "Factory Method 패턴"
  },
  {
    "question": "복잡한 객체의 생성 과정을 단계별로 나누어 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있게 하는 디자인 패턴은 무엇인가?",
    "answer": "Builder 패턴"
  },
  {
    "question": "하나의 인터페이스로 여러 클래스의 기능을 접근할 수 있도록 복잡한 시스템을 단순화하는 패턴은 무엇인가?",
    "answer": "Facade 패턴"
  },
  {
    "question": "한 객체가 다른 객체에게 요청을 보내 일을 위임하는 디자인 패턴은 무엇인가?",
    "answer": "Delegate 패턴"
  },
  {
    "question": "객체들의 상태 변화를 관찰하는 여러 객체에 자동으로 통보해 상태를 일관성 있게 유지하는 디자인 패턴은 무엇인가?",
    "answer": "Observer 패턴"
  },
  {
    "question": "기존 객체에 새로운 기능을 동적으로 추가하는 구조적 디자인 패턴은 무엇인가?",
    "answer": "Decorator 패턴"
  },
  {
    "question": "서로 다른 인터페이스를 가진 클래스를 함께 동작할 수 있도록 변환하는 패턴은 무엇인가?",
    "answer": "Adapter 패턴"
  },
  {
    "question": "한 클래스에 인스턴스가 오직 하나만 존재하도록 보장하는 디자인 패턴은 무엇인가?",
    "answer": "Singleton 패턴"
  },
  {
    "question": "객체의 내부 상태를 저장하고 필요할 때 그 상태를 복원할 수 있도록 하는 패턴은 무엇인가?",
    "answer": "Memento 패턴"
  },
  {
    "question": "객체들의 인터페이스를 일관성 있게 중재하여 객체들 간의 복잡한 상호작용을 단순화하는 패턴은 무엇인가?",
    "answer": "Mediator 패턴"
  },
  {
    "question": "객체 생성을 추상화하여 구체적인 생성 클래스를 숨기고, 관련된 객체들을 함께 생성하는 패턴은 무엇인가?",
    "answer": "Abstract Factory 패턴"
  },
  {
    "question": "복합 객체를 트리 구조로 표현하여 부분-전체 계층을 동일하게 처리할 수 있도록 하는 패턴은 무엇인가?",
    "answer": "Composite 패턴"
  },
  {
    "question": "객체 접근을 제어하거나 추가 기능을 제공하기 위해 객체에 대한 접근을 제어하는 대리인을 제공하는 패턴은 무엇인가?",
    "answer": "Proxy 패턴"
  },
  {
    "question": "기능의 변경 없이 객체의 행위를 확장하거나 변형할 수 있도록 하는 패턴은 무엇인가?",
    "answer": "Decorator 패턴"
  },
  {
    "question": "객체 생성 과정과 관련된 패턴을 통칭하는 용어는 무엇인가?",
    "answer": "생성 패턴 (Creational Patterns)"
  },
  {
    "question": "클래스나 객체를 조합하여 큰 구조를 만드는 패턴을 통칭하는 용어는 무엇인가?",
    "answer": "구조 패턴 (Structural Patterns)"
  },
  {
    "question": "객체 간의 책임 분배와 상호작용을 다루는 패턴을 통칭하는 용어는 무엇인가?",
    "answer": "행위 패턴 (Behavioral Patterns)"
  },
  {
    "question": "Singleton, Factory Method, Builder 등이 속하는 디자인 패턴 분류는 무엇인가?",
    "answer": "생성 패턴 (Creational Patterns)"
  },
  {
    "question": "Adapter, Decorator, Facade 등이 속하는 디자인 패턴 분류는 무엇인가?",
    "answer": "구조 패턴 (Structural Patterns)"
  },
  {
    "question": "Observer, Strategy, Command 등이 속하는 디자인 패턴 분류는 무엇인가?",
    "answer": "행위 패턴 (Behavioral Patterns)"
  },
  {
    "question": "프로그램 내의 모든 명령문이 한 번 이상 실행되도록 테스트하는 커버리지는 무엇인가?",
    "answer": "문장 커버리지 (Statement Coverage)"
  },
  {
    "question": "프로그램 내의 모든 조건식이 참과 거짓의 두 가지 결과를 최소 한 번 이상 갖도록 테스트하는 커버리지는 무엇인가?",
    "answer": "조건 커버리지 (Condition Coverage)"
  },
  {
    "question": "프로그램의 모든 분기점(조건문)의 참/거짓이 최소 한 번씩 실행되도록 테스트하는 커버리지는 무엇인가?",
    "answer": "분기 커버리지 (Branch Coverage)"
  },
  {
    "question": "조건식의 모든 개별 조건과 그 조건이 포함된 분기의 모든 참/거짓 결과를 결합하여 테스트하는 커버리지는 무엇인가?",
    "answer": "조건/분기 커버리지 (Condition/Decision Coverage)"
  },
  {
    "question": "프로그램의 모든 경로가 한 번 이상 실행되도록 테스트하는 가장 엄격한 커버리지는 무엇인가?",
    "answer": "경로 커버리지 (Path Coverage)"
  },
  {
    "question": "상위 클래스에서 알고리즘의 뼈대를 정의하고 구체적인 단계는 하위 클래스에서 정의하는 패턴\n 알고리즘의 구조(고정적 기능)를 변경하지 않고 알고리즘의 특정 단계들을 재정의할 수 있다.",
    "answer": "Tepmlate Method"
  },
  {
    "question": "네트워크 상의 컴퓨터와 가동 서비스를 탐색하여 장비 구성, 포트 구성등을 파악하는 보안공격방식?",
    "answer": "스캐닝(Scanning)"
  },
  {
    "question": "하나의 문제를 해결하기 위해 여러 모듈들이 순차적으로 수행되는경우의 응집도",
    "answer": "절차적(Procedural)응집도"
  },
  {
    "question": "롤백을 통해 객체의 상태를 이전 상태로 되돌릴 수 있는 기능을 제공하는 패턴\n 객체의 캡슐화가 유지되는 상태에서 객체 내부 상태를 외부에 저장하여 복구가 가능하도록 한다.",
    "answer": "Memento"
  },
  {
    "question": "MD 를 대체하기 위해 미국 NIST 에서 개발한 해시 암호화 알고리즘",
    "answer": "SHA(Secure Hash Algorithm)"
  },
  {
    "question": "객체 구조와 그 구조에 적용될 연산을 분리하여 구조는 변경하지 않고 연산을 새롭게 정의할 수 있도록 하는 디자인 패턴은 무엇인가?",
    "answer": "Visitor 패턴"
  },
  {
    "question": "복잡한 알고리즘의 구조를 캡슐화하고, 알고리즘의 skeleton(골격)을 정의하며, 하위 클래스에서 구체적인 단계를 재정의할 수 있도록 하는 패턴은 무엇인가?",
    "answer": "Template Method 패턴"
  },
  {
    "question": "객체가 상태에 따라 행위를 변경할 수 있도록 하고, 상태가 객체로 표현되며 상태 전환이 유연하게 이루어지도록 하는 디자인 패턴은 무엇인가?",
    "answer": "State 패턴"
  },
  {
    "question": "요청을 보내는 쪽과 처리하는 쪽을 분리하고, 요청을 처리할 객체들을 사슬(chain)처럼 연결해 둘 중 하나가 요청을 처리할 수 있도록 하는 패턴은 무엇인가?",
    "answer": "Chain of Responsibility 패턴"
  },
  {
    "question": "객체들의 행위를 캡슐화하여 호출자(Invoker)가 실행 요청만 하고 구체적인 실행 방법은 객체가 스스로 처리하도록 하는 패턴은 무엇인가?",
    "answer": "Command 패턴"
  },
  {
    "question": "복잡한 언어의 문법을 클래스 구조로 표현하고, 언어의 문장을 해석하기 위한 인터프리터를 구현하는 패턴은 무엇인가?",
    "answer": "Interpreter 패턴"
  },
  {
    "question": "객체들의 순차적인 접근 방법을 제공하여 내부 구현에 상관없이 집합체 요소들을 순차적으로 접근할 수 있도록 하는 패턴은 무엇인가?",
    "answer": "Iterator 패턴"
  },
  {
    "question": "다음 설명에 대해 괄호 안에 알맞는 용어를 작성하시오. (영어 약자로 작성하시오.)\n\n \n\n \n\n(     )은/는 자료를 일정한 크기로 정하여 순서대로 전송하는 자료의 전송 방식이다.\n \n\n셀이라 부르는 고정 길이 패킷을 이용하여 처리가 단순하고 고속망에 적합하며, 연속적으로 셀을 보낼 때 \n다중화를 하지 않고 셀단위로 동기가 이루어지지만 경우에 따라 동기식 시간 분할 다중화를 사용하기도 한다.\n \n\n가상 채널 (Virtual Channel) 기반의 연결 지향 서비스로 셀이라 부르는 고정 길이(53바이트) 패킷을 사용하며 통계적 다중화 방식을 이용한다.",
    "answer": "ATM"
  },
  {
    "question": "64bit의 블록크기를 가지고 키길이는 128bit 8라운드 진행하고, DES 를 대체하기 위해 스위스에서 개발된 알고리즘은 ?",
    "answer": "IDEA"
  },
  {
    "question": "RSA의 대안으로 대두된 이산대수의 난해성에 기반한 공개키 암호화 알고리즘, 비트코인 등에서 사용 RSA 보다 수십 배 빠름",
    "answer": "ECC(elliptic Curve Crypto)"
  },
  {
    "question": "대표적인 블록 암호 방식의 대칭키 알고리즘으로, 56비트의 키를 사용하며 64비트 단위로 데이터를 암호화하는 알고리즘은 무엇인가?",
    "answer": "DES (Data Encryption Standard)"
  },
  {
    "question": "미국 NIST에서 DES를 대체하기 위해 고안된 대칭키 블록 암호화 알고리즘으로, 128, 192, 256비트 키를 지원하며 Rijndael 알고리즘에 기반한 것은 무엇인가?",
    "answer": "AES (Advanced Encryption Standard)"
  },
  {
    "question": "주체가 소유한 객체에 대해 접근 권한을 주체가 임의로 설정하거나 다른 사용자에게 부여할 수 있도록 하는 접근 통제 방식은 무엇인가?",
    "answer": "DAC (Discretionary Access Control, 임의 접근 통제)"
  },
  {
    "question": "군사 및 정부 시스템에서 주로 사용되며 보안 등급에 따라 접근 권한을 강제적으로 부여하는 접근 통제 모델은 무엇인가?",
    "answer": "MAC (Mandatory Access Control, 강제 접근 통제)"
  },
  {
    "question": "조직 내 역할(Role)에 따라 사용자의 접근 권한을 정의하고 관리하는 접근 통제 방식은 무엇인가?",
    "answer": "RBAC (Role Based Access Control, 역할 기반 접근 통제)"
  },
  {
    "question": "사용자가 자신의 자원에 대해 다른 사용자에게 접근 권한을 위임하거나 부여할 수 있다는 특징을 가진 접근 통제 방식은 무엇인가?",
    "answer": "DAC (임의 접근 통제)"
  },
  {
    "question": "미국 NIST에서 전자서명 표준에서 사용하기 위해 정부용 공개키 알고리즘 EIGammal 알고리즘을 기반으로 만들어짐",
    "answer": "DSA"
  },
  {
    "question": "인증되지 않은 사용자가 타인의 신분을 위조하여 시스템에 접근하거나 허가되지 않은 작업을 수행하는 공격 기법은 무엇인가?",
    "answer": "스푸핑 (Spoofing)"
  },
  {
    "question": "공격자가 네트워크 상의 데이터 패킷을 몰래 수집하여 ID, 패스워드 등 중요한 정보를 빼내는 행위는 무엇인가?",
    "answer": "스니핑 (Sniffing)"
  },
  {
    "question": "주로 네트워크 관리자나 공격자가 다른 사람의 컴퓨터나 네트워크 활동을 몰래 엿보거나 감시하는 행위를 지칭하는 용어는 무엇인가?",
    "answer": "스누핑 (Snooping)"
  },
  {
    "question": "유선과 동일한 수준의 보안을 무선 네트워크에서 제공하기 위해 IEEE 802.11 표준에서 사용된 초기 무선 LAN 보안 프로토콜은 무엇인가?",
    "answer": "WEP (Wired Equivalent Privacy)"
  },
  {
    "question": "상위 클래스에서는 객체를 생성하기 위한 인터페이스를 정의하고 하위클래스는 어떤 클래스의 인스턴스를 생성할 것인지 결정하는 패턴",
    "answer": "Factory Method"
  }
]
